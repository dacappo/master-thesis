\chapter{NoSQL Injection Attacks}
This chapter gives an overview of the in scope of this thesis found NoSQL injection attacks. Each of the presented attacks is accompanied by a vulnerable code example as well as a suitable attack vector. With regard to the attacker surface parameters analysed in section \ref{sec:analysisOfQueryTechniques}, the vectors focus on query-string, form data and JSON encoded payloads. At this point it needs to be said, that the presented code snippets are created for demonstration purposes and should not be deployed in practice. The chapter is structured in one section per investigated database.

\section{MongoDB}
Within this section, the newly discovered injection attacks against the document store MongoDB are outlined.

\subsection{Query Selector Injection}
This attack is based on the common attacker model and is directed against the selection parameter of queries. MongoDB employs BSON, an extended JSON format, to define the selected documents taken into account for the query. Complex selection operations, such as \emph{greater than} or \emph{not equal}, are implemented with the help of a set of special query selectors. These are formatted as objects and replace the actual value within the query criteria as demonstrated in listing \ref{lst:MongoQuerySelectors}. \\

\begin{lstlisting}[caption={Example for MongoDB's query selectors}, label={lst:MongoQuerySelectors}]
find({'password' : 'secure'});      // Password property equals "secure"
find({'password' : {'$ne': '0'}});  // Password property not equals "0"
\end{lstlisting}

The injection attack presented by Sullivan \cite{Sullivan:2011} showed, that query selectors in combination with PHP applications can be utilized for injection attacks. Listing \ref{lst:PHPQuerySelectorInjection} shows the according vulnerable code of an login implementation. \\

\begin{lstlisting}[caption={Vulnerable PHP example for query selector injection on MongoDB}, label={lst:PHPQuerySelectorInjection}]
$collection->find(array('user' => $_GET['user'], 'password' => $_GET['password']));
\end{lstlisting}

The code checks for documents, that match the passed user and password values from the query-string. Here comes the automatic query-string parsing of PHP into play. This feature enables the injection of a Query Selector instead of an actual password with the help of the extended query-string syntax. A passed selector like \emph{no equals} will nearly always evaluate to true. With the manipulated request shown in \ref{lst:QuerySelectorInjectionVector}, the login check can be reliably bypassed. \\

\begin{lstlisting}[caption={Attack vector on MongoDB for query selector injection via the query-string parameter}, label={lst:QuerySelectorInjectionVector}]
https://example.org/login?user=patrick&password[%24ne]=
\end{lstlisting}

With the help of the extended query syntax a query selector object with the url-espaced key \emph{\$ne} is injected. Pektov \cite{Petkov:2014a} demonstrated a vulnerable login implementation running on NodeJS's Express web server following the same approach. The application code given in listing \ref{lst:NodeQuerySelectorInjection} can also be attacked with the request presented in listing \ref{lst:QuerySelectorInjectionVector} . \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for query selector injection on MongoDB}, label={lst:NodeQuerySelectorInjection}]
db.collection('users').find({"user": req.query.user, "password": req.query.password});
\end{lstlisting}

So, are there even any new findings for this class of attack? The previous publications presented the query selector injection as a distinct issue occurring only for PHP and Node applications. However, the non-standardized application layer interpretation of query-string revealed to be a much bigger problem. As explained in section \ref{sec:analysisOfQueryTechniques}, the query-string parsing is a convenience functionality present across all investigated application platforms. The examples given in listing \ref{lst:RubyQuerySelectorInjection} for Ruby as well as listing \ref{lst:PythonQuerySelectorInjection} for Python reveal, that query selector injection is an issue appearing across platforms. \\

\begin{lstlisting}[caption={Vulnerable Ruby example for query selector injection on MongoDB}, label={lst:RubyQuerySelectorInjection}]
db['users'].find({:user => req.params['user'], :password => req.params['password']})
\end{lstlisting}

\begin{lstlisting}[caption={Vulnerable Python example for query selector injection on MongoDB}, label={lst:PythonQuerySelectorInjection}]
db.users.find({"user": request.GET['user'], "password": request.GET['password']})
\end{lstlisting}

In all of the four cases, the default and by MongoDB recommended database driver was deployed \cite{MongoDB_Drivers2016}. The attack vector from listing \ref{lst:QuerySelectorInjectionVector} leads in each of the presented login checks to the query criteria shown in listing \ref{lst:QuerySelectorInjectionResult} in contrast to the expected criteria shown in listing \ref{lst:QuerySelectorNormalResult}. \\

\begin{minipage}{.97\textwidth}
\begin{minipage}[t]{.49\textwidth}
\begin{lstlisting}[caption={Resulting query of normal request}, label={lst:QuerySelectorNormalResult}]
{'user': 'patrick', 
 'password': '1234'}
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{.49\textwidth}
\begin{lstlisting}[caption={Resulting query of query selector injection}, label={lst:QuerySelectorInjectionResult}]
{'user': 'patrick',
 'password': {'&gt':''}}
\end{lstlisting}
\end{minipage}
\end{minipage}

A login can therefore be bypassed in each investigated case, but this kind of attack is not restricted to login applications. Nearly all parameterized selection criteria can be influenced by the injection of query selectors. This includes all read, update and delete calls making use of the BSON selection format. Affected functions of the MongoDB API are listed in table \ref{tab:mongo_commands_affected}.\\

\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{lll}
  \textbf{Command} & \textbf{Arguments} \\ \hline
  db.collection.deleteOne         & \textbf{filter} options \\
  db.collection.deleteMany        & \textbf{filter} options \\
  db.collection.find              & \textbf{query} projection \\
  db.collection.findAndModify     & \textbf{query} options \\
  db.collection.findOne           & \textbf{query} projection \\
  db.collection.findOneAndDelete  & \textbf{filter} options \\
  db.collection.findOneAndReplace & \textbf{filter} replacement options \\
  db.collection.findOneAndUpdate  & \textbf{filter} update options \\
  db.collection.replaceOne        & \textbf{filter} replacement options \\
  db.collection.remove            & \textbf{query} option \\
  db.collection.update            & \textbf{query} update options \\
  db.collection.updateOne         & \textbf{filter} update options \\
  db.collection.updateMany        & \textbf{filter} update options \\
  \bottomrule 
 \end{tabular}
 \caption{MongoDB commands affected by query selector injection}
 \label{tab:mongo_commands_affected}
\end{table}

Considered are collection functions, that employ either a \emph{filter} or \emph{query} parameter. Both facilitate the same JSON-like selection format. The affected functions encompass read, update and delete operations. Furthermore, the attacker surface analysis from section \ref{sec:analysisOfQueryTechniques} suggests, that the URL query-string is by far not the only part of the attacker surface allowing this kind of attack. When the application processes other request parameters, the payload can also be placed in form data encoded as well as JSON request bodies. Especially the form data based injection was not taken into account by earlier publications. These circumstances exhibit a way more significant surface for query selector injection as previously indicated. \\

\textbf{Attack Summary} \\
MongoDB's flexible query scheme in combination with the query selector objects make it vulnerable for this kind of injection attack. In general, all non-relational databases employing JSON-like query structures with object structure encoding are potentially vulnerable. The main problem of this attack is the realization of complex query operations. Equality selections can be simply encoded within a JSON-like structure, but for operations as \emph{greater than} a special syntax is required. Thereby each equality check can be replaced by complex query operators, when the object structure is under control of an attacker. All parameters of the attacker surface that allow object structure encoding can be used for this kind of injection. The attack works across all investigated application platforms and with common drivers as well as direct REST interface access. 

\subsection{Expanding Array Injection}
The expanding array injection is based on the common attacker model and exploits a special behaviour of a query's selection criteria. When selection criteria requires a property to be equal to a value and the stored document contains an array in place of the property, all values of the array are used to find a match. This feature, as the attack name implies, is called automatic array expanding. An attacker can manipulate inserted documents in order to achieve unintended matches for subsequent queries employing selection criteria. The creation of a user as shown in listing \ref{lst:NodeJSCreateUser} represents an example for such an vulnerability. \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for expanding array injection on MongoDB}, label={lst:NodeJSCreateUser}]
if (req.query.user !== "admin") {
  db.collection('users').insert({"user": req.query.user, "password": req.query.password});
}
\end{lstlisting}

The given code allows the insertion of new users into the database, with the exception of \emph{admin} as a username. This security check can be bypassed, by injecting an array of usernames instead of a simple string. A suitable attack vector based on query-string encoding is given with listing \ref{lst:ExpandingArrayInjection}.\\

\begin{lstlisting}[caption={Attack vector on MongoDB for expanding array injection via the query-string parameter}, label={lst:ExpandingArrayInjection}]
https://example.org/register?user[]=patrick&user[]=admin&password=1234;
\end{lstlisting}

The given request creates an array-typed \emph{user} property that leads to the bypass of the if-clause. In the next step, the query is executed and the provided data results into the document presented in listing \ref{lst:ExpandingArrayInjectionDocument} stored within the user collection.\\

\begin{lstlisting}[caption={Resulting parameter for expanding array injection}, label={lst:ExpandingArrayInjectionDocument}]
{'user': ['patrick', 'admin'], 'password': 1234}
\end{lstlisting}

At this point, the array expanding functionality becomes important. An attacker can now use the normal authentication with username and password as shown in listing \ref{lst:NodeJSArrayExpandingLogin} to login. This works for both of the users inserted with the initial request. \\

\begin{lstlisting}[caption={Login example affected by the preceding expanding array injection}, label={lst:NodeJSArrayExpandingLogin}]
db.collection('users').find({"user": req.query.user, "password": req.query.password});
\end{lstlisting}

The subsequent request for the login does not even have to be manipulated. An attacker can now login as admin with a usual authentication request as shown in listing {lst:ArrayExpandingAdminLogin}.\\

\begin{lstlisting}[caption={Usual login request exploiting the injected user array}, label={lst:ArrayExpandingAdminLogin}]
https://example.org/login?user=admin&password=1234;
\end{lstlisting}

MongoDB will search for a document with the user property set to \emph{admin} and the password property set to \emph{1234}. Through the expansion the beforehand injected document or respectively the user property, a matching document is found and the admin login is successful.\\

The presented login application is of course not the only example, where the expanding array feature of MongoDB allow injection attacks. Every insert operation with data originating from the three parameters, that allow type manipulation represents a potential vulnerability. It enables an attacker to break the confidentiality of the underlying data, which leads to unintended matches for further requests. The attack was exemplified for the NodeJS, but is relevant for all of the investigated application layers. Table \ref{tab:mongo_commands_affected_expanding_array} gives an overview of the affected database interface functions.\\

\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{lllll}
  \textbf{Command} & \textbf{Arguments} \\ \hline
  db.collection.insert            & \multicolumn{3}{l}{\textcolor{dark-red}{\textbf{document}} | [ \textcolor{dark-red}{\textbf{document ... }} ] } \\
  db.collection.insertOne         & \textcolor{dark-red}{\textbf{document}} \\ 
  db.collection.update            & \textcolor{dark-blue}{\textbf{query}} \textcolor{dark-red}{\textbf{update}} options \\
  db.collection.updateOne         & \textcolor{dark-blue}{\textbf{filter}} \textcolor{dark-red}{\textbf{update}} options \\
  db.collection.updateMany        & \textcolor{dark-blue}{\textbf{filter}} \textcolor{dark-red}{\textbf{update}} options \\
  db.collection.replaceOne        & \textcolor{dark-blue}{\textbf{filter}} \textcolor{dark-red}{\textbf{replacement}} options \\\hdashline
  db.collection.deleteOne         & \textcolor{dark-blue}{\textbf{filter}} options \\
  db.collection.deleteMany        & \textcolor{dark-blue}{\textbf{filter}} options \\
  db.collection.find              & \textcolor{dark-blue}{\textbf{query}} projection \\
  db.collection.findAndModify     & \textcolor{dark-blue}{\textbf{query}} options \\
  db.collection.findOne           & \textcolor{dark-blue}{\textbf{query}} projection \\
  db.collection.findOneAndDelete  & \textcolor{dark-blue}{\textbf{filter}} options \\
  db.collection.findOneAndReplace & \textcolor{dark-blue}{\textbf{filter}} replacement options \\
  db.collection.findOneAndUpdate  & \textcolor{dark-blue}{\textbf{filter}} update options \\
  db.collection.remove            & \textcolor{dark-blue}{\textbf{query}}  option \\
  \bottomrule 
 \end{tabular}
 \caption{MongoDB commands affected by expanding array injection}
 \label{tab:mongo_commands_affected_expanding_array}
\end{table}

The red highlighted parameters allow the actual insertion of documents, whereby a property is replaced with an array. All blue highlighted parameters are then affected by automatically expanding the injected arrays. Nearly all notable interface functions are direct or indirectly affected by this kind of attack. \\

\textbf{Attack Summary} \\
MongoDB's feature for automatic array expansion of stored documents allows this kind of attack. In general, all non-relational databases employing automatic structure resolving or changes are potentially vulnerable. The main problem of this attack is that all stored arrays are expanded by default, but the behaviour is neither typical nor expected in this context. When an attacker is able to inject an array instead of a normal value, all following selection operations will expand the arrays content for the search and therefore change their behaviour. All request parameters of the attacker surface enabling object structure manipulation can be deploy for the expanding array injection. The attack works across all investigated application platforms and with common drivers as well as direct REST interface access. 

\section{Redis}
This section covers the injection attacks against the key-value store Redis, that were found in scope of this thesis.

\subsection{Parameter Overwrite Injection}
The parameter overwrite injection against Redis is based on the common attacker model. It requires NodeJS as an application platform in combination with the most prevalent Redis driver \cite{Ranney2016}. In order to understand this attack, it is essential to know how parameters can be passed to this particular database driver. The regular way allows to define each parameter as distinct argument. An alternative way allows to pass all parameters within a single array as the first argument of the interface call. With this knowledge and the control of the first argument, an attacker is able to overwrite the following arguments of a driver function call. An example application, where this becomes critical is shown in listing \ref{lst:parameterOverwriteApp}. \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for parameter overwrite injection on Redis}, label={lst:parameterOverwriteApp}]
RedisClient.expireat(req.query.key, new Date("November 8, 2026 11:13:00").getTime());
\end{lstlisting}

This code makes use of the \emph{expireat} functionality to set the data for the deletion of an entry. In this particular case, the expire date of the entry behind the passed key is set to a date far in the future. The user can therefore only extend the life of an entry behind an arbitrary key, but not really influence the stored data in a negative way. This situation changes, when the second parameter can be overwritten. A conceivable attack could set the expire data to a time in the past. A request, that triggers exactly this operation is shown in listing \ref{lst:parameterOverwriteAtt}. \\

\begin{lstlisting}[caption={Attack vector on Redis for query selector injection via the query-string parameter}, label={lst:parameterOverwriteAtt}]
https://example.org/expire?key[]=foo&key[]=1117542887
\end{lstlisting}

Given the query-string parameters, an array will be created and passed as the first argument to the database call. The second parameter, containing a future point of time will be overwritten. Instead the injected timestamp passed within the array in the first argument will be used. Since this timestamp lays in the past, the stored data behind the provided key will be deleted. This enables an attacker to remove arbitrary entries of the database! Similar to the presented attack on \emph{expireat}, there exist multiple other affected database commands. An excerpt of commands, that are vulnerable for parameter overwrite injection are listed within table \ref{tab:redis_commands_affected}. \\

\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{lll}
  \textbf{Command} & \textbf{Arguments} & \textbf{Injection Description} \\ \hline
  Append  & key value       & Append a value to an arbitrary key\\
  DecrBy  & key decrement   & Decrement the integer value of a selected key \\
  Del     & key [key ...]   & Delete multiple selected keys at once \\
  Exists  & key [key ...]   & Check existence of multiple keys at once \\
  Expire  & key second      & Delete arbitrary key \\
  ExpireAt& key timestamp & Delete arbitrary key \\
  GetRange& key start end & Get entire content of key \\
  GetSet  & key value & Overwrite value of selected key \\
  IncrBy  & key increment & Increment the integer value of a selected key \\
  Move    & key db & Set destination database \\
  Rename  & key newkey & Set new key \\
  Set     & key value [expire] & Set arbitrary key-value data \\
  \bottomrule 
 \end{tabular}
 \caption{Redis commands affected by parameter overwrite injection}
 \label{tab:redis_commands_affected}
\end{table}

The investigation revealed, that many of the commands allow parameter overwrites and therefore corruption of query behaviour as well as the underlying data. When the first key argument is controlled by an attacker, all following ones can be overwritten. These vulnerabilities enable an attacker to perform unintended insert, update or delete operations. \\

\textbf{Attack Summary} \\
Of the investigated databases, Redis in combination with NodeJS is the only technology stack affected by this attack. In general, all non-relational databases employing overloaded interface functions are potentially vulnerable. The main problem of this attack is, that the database driver allows two ways to pass arguments to the query. When an attacker is in control of the first parameter, the argument format can be influenced and the following arguments are overwritten. All object structure encoding request parameters of the attacker surface can be deploy for parameter overwrite injection. The attack works on NodeJS in combination with the recommended Redis driver. 

\section{CouchDB}
Within this section, the discovered injection attacks against the document store CouchDB are outlined.

\subsection{Find Selector Injection}
This attack is based on the common attacker model and directed against the find operation of CouchDB. The database facilitates two techniques to retrieve data. One is to reference the required document by its key. When selection criteria for other properties is needed, documents are queried with JSON-like selection criteria via the special \emph{\_find} document. This document is available within every database collection and resolves the passed selection criteria. The find selector injection focuses on manipulation of the provided selection criteria. Similar to MonogDB, complex criteria, like \emph{greater than} and \emph{not equals}, is encoded by query selector objects. These can be misused by object structure injection. The example given by listing \ref{lst:FindSelectorInjectionNodeJS} implements a credentials check and is vulnerable for find selector injection. \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for find selector injection on CouchDB}, label={lst:FindSelectorInjectionNodeJS}, language=JavaScript]
function checkCredentials(user, password, callback) {
  var options = {'selector': {'user': user, 'password': password}};
  couch.use('users').get('_find', options, (err, res) => {
    callback(res.docs.length === 1);
  });
}

checkCredentials(req.query.user, req.query.password, handleResult);
\end{lstlisting}

A function is implemented, that returns true or false depending on the success of the credentials check. The provided user and password value become part of the selector object, that is in turn contained within the options. Couch selects the user collection and performs a get operation with the help of the \emph{\_find} document and the composed options. Only when exactly one document is found that matches the selection criteria, the callback returns true. The described function is called with values provided by the request. Through object structure injection, the attack shown in listing \ref{lst:FindSelectorInjectionAttack} can be conducted. \\

\begin{lstlisting}[caption={Attack vector on CouchDB for speical key injection via the query-string parameter}, label={lst:FindSelectorInjectionAttack}]
https://example.org/login?user=patrick&password[%24ne]=1
\end{lstlisting}

The payload contained within the query-string of the URL leads to an object instead of a string typed password property. This object will replace the provided password value with a \emph{not equals} selector object within the query options. Therefore, the password check will reliably evaluate to true and the credentials check is bypassed. Table \ref{tab:couchdb_affected_selectors} provides an overview of available query selector objects within CouchDB. \\

\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{ll}
  \textbf{Operator} & \textbf{Description} \\ \hline
  \$lt      & less than argument\\
  \$lte     & less than or equal to argument \\
  \$eq      & equal to argument \\
  \$ne      & not equal to argument \\
  \$gte     & greater than or equal to the argument \\
  \$gt      & greater than argument \\
  \$exists  & field exists \\
  \$type    & type equals \\
  \$in      & contained in list \\
  \$nin     & not contained in list \\
  \$size    & length equal \\
  \$mod     & modulus equals remainder \\
  \$regex   & regular expression \\
  \$and     & all contained selectors match \\
  \$or      & any of the contained selectors matches \\
  \$not     & selector does not match \\
  \$nor     & no contained selector matches \\
  \$all     & contains all elements of argument list \\ 
  \$elemMatch & at least one of the contained selectors matches \\
  \bottomrule 
 \end{tabular}
 \caption{CouchDB's selector operations utilized for find selector injection}
 \label{tab:couchdb_affected_selectors}
\end{table}

Since this attack does not only apply to credentials checks, the variety of query selectors can be used depending on the attacked application. Operations making use of the \emph{\_find} document are therefore very sensible for type and object structure injections.

\textbf{Attack Summary} \\
Similar to MongoDB, selection queries based on JSON structures allow this kind of attack. As described before, all non-relational databases extending this JSON structure with special objects for complex queries are potentially vulnerable. The main problem of this attack is, that objects with certain properties are treated special in order to enable complex document selections. When attacker is able to injection such objects instead of a normal value, other documents are selected for further query processing. All object structure encoding request parameters of the attacker surface can be deploy for find selector injection. The attack works across all investigated application platforms and with common drivers as well as direct REST interface access. 

\subsection{Special Key Injection}
The special key injection against CouchDB rests upon the common attacker model. In order to understand this attack, it is vital to be aware of CouchDB's storage concept. All data needed for its operation is treated as a document. This concerns application data as well as meta data of the existing collections. Security settings, operation history and data views are stored as documents within each collection. The only difference in comparison to normal documents is the prefixed underscore of the id. Meta data documents are accessible for every user with reading access on the collection. Special documents like those can be used to bypass application layer checks. Listing \ref{lst:SpecialKeyInjectionNodeJS} displays an authentication check vulnerable to special key injection. \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for special key injection on CouchDB}, label={lst:SpecialKeyInjectionNodeJS}, language=JavaScript]
function checkCredentials(user, password, callback) {
  couch.use('users').get(user, (err, res)=> {
    callback(res.password === password);
  });
}

checkCredentials(req.query.user, req.query.password, handleResult);
\end{lstlisting}

The snippet implements a \emph{checkUser} function, that receives a user and password argument. Since CouchDB's concept does not feature secure selection operations as outlined by the previous attack, documents are retrieved by their id. Other properties of the stored documents, such as the password, are not filtered directly. In the presented case, the user property represents the document key and is used to query the stored record from the database. Password matching between the retrieved document and the passed argument is accomplished by the application layer. The result of the password matching is returned by the callback. \\

An attacker is able to bypass this authentication check with the help of the stored meta data documents. The request presented in listing \ref{lst:SpecialKeyInjectionAttack} leads to a successful authentication.
 
\begin{lstlisting}[caption={Attack vector on CouchDB for speical key injection via the query-string parameter}, label={lst:SpecialKeyInjectionAttack}]
https://example.org/login?user=_all_docs
\end{lstlisting}

With the provided user value, a special document is requested instead of a normal record. The database returns the \emph{\_all\_docs} document, that contains meta information about the collection. Important at that point is, that the special document does not contain a password property and the according value is therefore undefined. Since the attack vector does not define a password value, the resulting argument is also undefined. Thus, two undefined values are compared for equality. JavaScript as well as Python, Ruby and PHP will evaluate such comparisons to true and pass it to the callback. As a result, the credentials check is successfully bypassed.\\

CouchDB implements a group of these special documents for different purposes. Not all of these documents have the same access authorization level. Each of the special documents can be accessed by designated HTTP methods, as shown for a subset by table \ref{tab:couch_special_documents}. \\

\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{llcccc}
  \textbf{Key} & \textbf{Description} & \textbf{GET} & \textbf{POST} & \textbf{PUT} & \textbf{DEL} \\ \hline
  \rowcolor{light-gray}\_all\_docs             & Return multiple documents of a database   & \cmark & \cmark & \xmark & \xmark \\
  \_bulk\_docs            & Create and update multiple documents      & \xmark & \cmark & \xmark & \xmark \\
  \rowcolor{light-gray}\_design                & Create or return views of database        & \cmark & \cmark & \xmark & \xmark \\
  \_find                  & Find documents with selection criteria    & \xmark & \cmark & \xmark & \xmark \\
  \rowcolor{light-gray}\_index                 & Get or create index                       & \cmark & \cmark & \xmark & \cmark \\
  \_explain               & Explain database structure                & \xmark & \cmark & \xmark & \xmark \\
  \rowcolor{light-gray}\_changes               & List of changes in the database           & \cmark & \cmark & \xmark & \xmark \\
  \_compact               & Run compression of database               & \xmark & \cmark & \xmark & \xmark \\
  \_ensure\_full\_commit  & Commits changes to disk                   & \xmark & \cmark & \xmark & \xmark \\
  \rowcolor{light-gray}\_security              & Return or set security object of database & \cmark & \xmark & \cmark & \xmark \\
  \_purge                 & Remove references to deleted documents    & \xmark & \cmark & \xmark & \xmark \\
  \_missing\_revs         & Return not stored revisions               & \xmark & \cmark & \xmark & \xmark \\
  \_revs\_diff            & Returns diff to stored revisions          & \xmark & \cmark & \xmark & \xmark \\
  \rowcolor{light-gray}\_revs\_limit           & Returns current revision limit            & \cmark & \xmark & \cmark & \xmark \\
  \bottomrule 
 \end{tabular}
 \caption{CouchDB special documents with description and applicable HTTP methods}
 \label{tab:couch_special_documents}
\end{table}

Depending on the operational purpose of the special document, designated HTTP methods are appointed. This has to be considered for attacks, since the injected special document needs to support the applied HTTP method of the exploited query. In case of the shown injection example, the HTTP GET method had to be supported. A major advantage of an attacker is, that even the lowest authorization level is allowed to GET special documents. Special key injection against queries using other HTTP methods require a higher authorization level of the underlying database user. A correctly configured application server and database should prevent higher authorization levels for normal database operations Therefore, the special documents available via GET requests are particularly interesting for this attack. \\

\textbf{Attack Summary} \\
CouchDB's approach of handling all data as stored documents enables this kind of attack. In-general, all non-relational databases storing additional information in the same context as normal application data are vulnerable. The main problem of this attack is, that meta information of the collections is stored as documents within each collection. The authorization model allows reading access on this data for all users. Some applications may not pay regard to that and only expect application data. An attacker can use these special documents to retrieve documents with unexpected structures and therefore influence application layer logic. All object structure encoding request parameters of the attacker surface can be deploy for find selector injection. The attack works across all investigated application platforms and with common drivers as well as direct REST interface access. 

\subsection{Array Value Injection}
This attack is based on the common attacker model and directed against preliminary data validation. CouchDB implements protective measures for its special documents, but user defined documents have to be protected otherwise. Data checks within the application layer represent a solution for data protection. Inputs leading to illegitimate operations can be filtered beforehand in order to prevent query execution. At this point it is essential to filter all inputs giving a rise to the protected operation. Reliable filtering is hard to guarantee, when conditionals are handled differently on the application and database layer. Listing \ref{lst:couch_array_key_injection} gives an example for document protection, that can be bypassed by array value injection.\\

\begin{lstlisting}[caption={Vulnerable NodeJS example for array key injection on CouchDB}, label={lst:couch_array_key_injection}, language=JavaScript]
function getDocument(key, callback) {
  if (key === "secretDoc" || key[0] === "_") {
    callback("No access!");
  } else {
    couch.use('documents').get(key, callback);
  }
}

getDocument(req.query.key, handleResult);
\end{lstlisting}

The given code implements a function to retrieve documents by key. In order to protect the access on special documents and the \emph{secretDoc}, filters are applied. Special keys are filtered by the first underscore char and the secret document is protected by direct key comparison. Every other key is passed to the query and the according document is returned. An attack has to search for a second query syntax, that allows access to the protected documents and all the same passes the preliminary checks. Listing \ref{lst:couch_array_key_injection_attack} presents two requests, that bypass the protective measures and retrieve the documents. \\

\begin{lstlisting}[caption={Attack vectors on CouchDB for array key injection via the query-string parameter}, label={lst:couch_array_key_injection_attack}]
https://example.org?key[]=secretDoc
https://example.org?key[]=_all_docs
\end{lstlisting}

Basically, the attacks wrap an array around the passed key value. This achieves a different treatment of the parameter in the application and database layer. The filters use type safe condition evaluation. Therefore, the first attack vector injects an array which is not equal to the \emph{secretDoc} string. The second attack vector bypasses check, since the first element of the array does not equal the underscore char. Within the database layer, arrays containing just one element are resolved to the contained value. In both cases, the sensitive documents are returned. For this kind of vulnerability, similarities between string and array objects in the NodeJS, PHP, Ruby and Python environment become critical. \\

\textbf{Attack Summary} \\
Automatic type conversion of query parameters within the database layer enables this kind of attack. In general, all non-relational databases employing automatic parameter conversion or extraction within the database layer are potentially vulnerable. The main problem of this attack is, that a value contained within a single element array is casted implicitly. When an attacker is able to inject a value within an array instead of the plain value, the database operation stays the same, but the application code may handle the parameter differently. All request parameters of the attacker surface that enable object structure manipulation can be deployed for array value injection. The attack works across all investigated application platforms and with common drivers as well as direct REST interface access. 

\subsection{URL Traversal Injection}
The URL traversal injection against CouchDB rests upon the common attacker model. This attack relies on CouchDB's REST interface, that is used for any communication between application and database layer. REST uses URLs to identify the targeted documents. Some query parameters, such as the key, are used to build these URLs. Based on this, the key has influence on the structure of the URL. Applications as shown in listing \ref{lst:couchdb_url_traversal_injection_app} are vulnerable for URL traversal injection. \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for URL traversal injection on CouchDB}, label={lst:couchdb_url_traversal_injection_app}, language=JavaScript]
function getDocument(key, callback) {
  couch.use('table').get(key, callback);
}

getDocument(req.query.key, handleResult);
\end{lstlisting}

The shown example implements a function, that retrieves documents by the according key. In the underlying request, the key becomes the first element of the URL's path section. This circumstance allows path traversal by key injection, when the slash sign is not escaped. At this point, the special documents come into play again. Accessing one of these special documents, would not break a security goal of the given application. The path traversal injection in combination with special \emph{\_design} documents allow access on other database views. This should not be possible with the \emph{get} operation of the CouchDB driver, since a dedicated function for separated view access is provided. The URL traversal injection therefore allows an attack reading access on all defined views of a collection. This vulnerability caused by incorrect argument escaping, can be found in the Nano driver for NodeJS. Listing \ref{lst:couch_url_traversal_injection_vector} shows an exemplary attack vector for the presented application. \\


\begin{lstlisting}[caption={Attack vector on CouchDB for URL traversal injection via the query-string parameter}, label={lst:couch_url_traversal_injection_vector}]
https://example.org/get?key=_design/credentials/_view/user_password
\end{lstlisting}

To retrieve data of another view, the key value is forged to access the \emph{credentials} design document with the \emph{user\_password} view. The attack is subject to the assumption, that a view leaks sensitive information. In this case, all password values can be accessed that may not be part of the default document view. \\

\textbf{Attack Summary} \\
Of the investigated databases, CouchDB is the only one affected by URL traversal injection. In general, all non-relational databases with RESTful interfaces and flawed parameter escaping can be concerned. The main problem of this attack is incorrect or even missing escaping of parameters, that become part of the query URL. All URL sections following the non-escaped parameter can be overwritten. This situation becomes harmful, when unintended operations can be triggered through changes of the query URL structure. When the REST interface is used without database drivers, the escaping has to be ensured by the application code. Drivers, as used in the displayed example, should escape parameters for the URL context. All selected request parameters of the attack surface can be used for the traversal injection, since it is based on string encoded semantic. The attack works for NodeJS in combination with the Nano driver. XHR based database access is vulnerable for this kind of attack across all platforms, when parameters are not sanitized for the URL context. 

\subsection{Data Import Injection}
This attack is based on the extended attacker model and directed against data imports from external sources. As explained before, the new generation of NoSQL databases lead to more diverse system landscapes. This entails more frequent data exchanges between systems. The widespread support for unstructured data may let data transfers seem an easy task for non-relational databases. In fact, data exchange between systems is critical with regard to injection attacks. Any external data source has to be carefully checked for the context of the destination database. Listing \ref{lst:couchdb_data_import_injection_app} shows a data import process for CouchDB, that leaves context checks disregarded.\\

\begin{lstlisting}[caption={Vulnerable NodeJS example for data import injection on CouchDB}, label={lst:couchdb_data_import_injection_app}, language=JavaScript]
function importData(data) {
  data.forEach((doc) => {
    couch.use('mixedData').insert(doc);
  });
}

importData(externalSource.getData());
\end{lstlisting}

Basically, the given code retrieves some data from an external source and passes it to an import function. This function takes the data and inserts all contained documents into the \emph{mixedData} collection of CouchDB. In principle, this collection can be used for a variety of different data sources. If an attacker is able to influence only parts of the external data, this non-validated import processing opens up a serious vulnerability. In order to exploit this flaw, a document as presented within listing \ref{lst:couchdb_data_import_injection_inject} has to be inserted into the external data source.

\begin{lstlisting}[caption={Critical document for data import injection against CouchDB}, label={lst:couchdb_data_import_injection_inject}, language=JavaScript]
{
  "_id" : "_design/example",
  "views" : {
    "attacker" : {
      "map" : "function(doc){ while(true){};}"
    }
  }
}
\end{lstlisting}

The shown data represents a design document within CouchDB. In probably any other context, the shown document is harmless. An attacker inserts this document into the external data source, such as a text file or another non-relational database. As soon as data from this source is imported by CouchDB, the special structure is detected and a new \emph{attacker} view is applied. This implies the execution of the \emph{map} function on all contained documents. At this point, the results of the view cannot be retrieved by the attacker, but high processing load can be caused through the injected \emph{map} function. This impairs other queries and therefore the availability of the stored data. \\

On top of this, the documents imported at this stage can be used in combination with the URL traversal attack. This combination allows an attacker access the beforehand injected view resulting in data leakage. In general, reading access on the existing views of a collection becomes problematic with the data import injection in mind. \\

\textbf{Attack Summary} \\
Of the investigated databases, CouchDB is the only one affected by data import injection. In general, all non-relational databases storing functional data in the same scope as normal data are potentially vulnerable. The main problem of this attack is the context change, that takes place through data import. Harmless and valid data in one data storage reaches a special meaning in the context of CouchDB. This situation also extends the possibilities for subsequent injection attacks. Given the condition of additional attacker defined data within the targeted database, the confidentiality of otherwise secure data can be compromised. In case of CouchDB, the import processing of design documents requires collection admin authorization, but no database wide administration rights. All selected request parameters can be used for the subsequent injection, since the attacker controlled data often simplifies attack vectors. The attack works across all investigated application platforms and with common drivers as well as direct REST interface access. 

\section{Memcached}
This section covers the injection attacks against the key-value cache Memcached, that were found in scope of this thesis.
\subsection{Array Key Injection}
This attack is based on the common attacker model and directed against internal query parameter conversions. By default, Memcached does not separate its data through collections. All cached data is stored within a single scope. Access control has to be considered in the application layer. In order to circumvent such preliminary parameter checks, an attacker is searching for alternative ways to trigger unintended database queries. An example for an application, that is vulnerable for array key injection shown in listing \ref{lst:memcached_array_key_injection_app}.\\

\begin{lstlisting}[caption={Vulnerable NodeJS example for array key injection against Memcached}, label={lst:memcached_array_key_injection_app}, language=JavaScript]
function getCachedValue(key) {
  if (key.indexOf('auth_') === 0){
    callback("Invalid key!");
  } else {
    memcached.get(key, (err, body)=>{
      callback(err || body);
    });
  }
}

getCachedValue(req.query.key, handleResult);
\end{lstlisting}

The given code implements a function to retrieve cached values from Memcached by the according key. Since sensitive data is mixed with normal data, the key is checked before the actual database query is run. In this scenario, the key of sensitive data is prefixed with \emph{\_auth} and should not be accessible in scope of this function. All other data does not require any authorization checks and is freely readable. An example for the sensitive data could be session cookies or credentials. An attacker is able to bypass the prefix check of the function by exploiting the automatic type conversion of Memcached parameters. The request shown in listing \ref{lst:memcached_array_key_injection_vector} successfully bypasses the checks and retrieves sensitive data. \\

\begin{lstlisting}[caption={Attack vectors on Memcached for array key injection via the query-string parameter}, label={lst:memcached_array_key_injection_vector}]
"https://exmaple.org?key[]=auth_patrick"
\end{lstlisting}

To bypass the preliminary data checks, similarities between string and arrays in dynamic typed languages, such as NodeJS, PHP, Python and Ruby, are used. An actually protected key string is passed within an array through the extended query-string syntax. The resulting array bypasses the \emph{indexOf} check, because the exact \emph{auth\_} string is not an element within the injected array. Afterwards, the array is passed as the key argument to the query. Memcached expects a string value instead of an array, and therefore extracts the first contained string. As a result, the protected dataset is returned.\\

Since this attack reveals a secondary way to preform particular queries, a missing type check of request parameters enables the bypassing of application layer checks. All functionalities, that can be called on string as well as on array values has to be taken into account. An overview of found functionalities shared by string and array values is given in table \ref{tab:mecached_affected_functions}.

\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{lllcccc}
  \textbf{Function} & \textbf{String} & \textbf{Array} & \textbf{NodeJS} & \textbf{PHP} & \textbf{Python} & \textbf{Ruby} \\ \hline
  [i]            & Return i$^{th}$ char             & Return i$^{th}$ element           & \cmark & \cmark & \cmark & \cmark \\
  index(str)     & Char index of str                & Array index of str                & \xmark & \xmark & \cmark & \xmark \\
  indexOf(str)   & Char index of str                & Array index of str                & \cmark & \xmark & \xmark & \xmark \\
  str in         & Contained in string              & Contained in array                & \xmark & \xmark & \cmark & \xmark \\
  length         & Length of string                 & Length of array                   & \cmark & \xmark & \cmark & \cmark \\
  len(param)     & Length of string                 & Length of array                   & \xmark & \xmark & \cmark & \xmark \\
  sizeOf(param)  & Length of string                 & Length of array                   & \xmark & \cmark & \xmark & \xmark \\ 
  slice(i,j)     & Chars i to j                     & Elements i to j                   & \cmark & \xmark & \xmark & \cmark \\ 
  concat(n)      & Concatenates string n            & Appends element n                 & \cmark & \xmark & \xmark & \xmark \\ \hline
 \end{tabular}
 \caption{Affected string and array functions for Memcached array key injection}
 \label{tab:mecached_affected_functions}
\end{table}

Listed are functions and properties with the according functionalities on strings an arrays. The investigated application layers partially employ different naming conventions for the same functionality. As the excerpt shows, the similarity between strings and arrays exists on every platform. Therefore, the array key injection can bypass checks on every platform. \\

\textbf{Attack Summary} \\
Of the investigated databases, Memcached is similar like CouchDB affected by array key injection. In general, all non-relational databases with automatic conversion of query parameters are potentially vulnerable. The main problem of this attack is, that different parameters lead to the same query behaviour. Since the concept of Memcached requires application layer authorization checks, all possible parameters leading to forbidden queries have to be considered. The exposed issue, that array parameters trigger the same queries as string parameters is not officially documented. Therefore, array parameters are often not taken into account for application layer checks and consequently bypasses are possible. Request parameters for this attack have to support object structure control. Query string, JSON bodies as well as form data are therefore relevant parts of the attacker surface. The injection works across all investigated application platforms and with common drivers. 