\chapter{NoSQL Injection Attacks}
This chapter gives an overview of the in scope of this thesis found NoSQL injection attacks. Each of the presented attacks is accompanied by a vulnerable code example as well as a suitable attack vector. With regard to the attacker surface parameters analyzed in section \ref{sec:analysisOfQueryTechniques}, the vectors focus on query string and JSON encoded payloads. At this point it needs to be told, that the presented code snippets are created for demonstration purposes and should not be deployed in practice. The chapter is structured in one section per investigated database.

\section{MongoDB}
Within this section, the newly discovered injection attacks against the document store MongoDB are outlined.

\subsection{Query Selector Injection}
This attack is based on the common attacker model and is directed against the selection parameter of queries. MongoDB employs BSON, an extended JSON format, to define the selected documents affected by the query. Complex selection operations, such as \emph{greater than} or \emph{not equal}, are implemented with the help of a set of special query selectors. These are formatted as objects and replace the actual value within the query criteria as demonstrated in listing \ref{lst:MongoQuerySelectors}.  \\

\begin{lstlisting}[caption={Example for MongoDB's query selectors}, label={lst:MongoQuerySelectors}]
find({'password' : 'secure'});      // Password property equals "secure"
find({'password' : {'$ne': '0'}});  // Password property not equals "0"
\end{lstlisting}

The injection attack presented by Sullivan \cite{Sullivan:2011} showed, that query selectors in combination with PHP applications can be utilized for injection attacks. Listing \ref{lst:PHPQuerySelectorInjection} shows the according vulnerable code of an login implementation. \\

\begin{lstlisting}[caption={Vulnerable PHP example for query selector injection on MongoDB}, label={lst:PHPQuerySelectorInjection}]
$collection->find(array('user' => $_GET['user'], 'password' => $_GET['password']));
\end{lstlisting}

The code checks for documents, that match the passed user and password values from the query string. Here comes the automatic query string parsing of PHP into play. This feature enables the injection of a Query Selector instead of an actual password with the help of the extended query string syntax. An passed selector like \emph{no equals} will nearly always evaluate to true. With the manipulated request shown in \ref{lst:QuerySelectorInjectionVector}, the login check can be reliably bypassed. \\

\begin{lstlisting}[caption={Attack vector on MongoDB for query selector injection via the query string parameter}, label={lst:QuerySelectorInjectionVector}]
https://example.org/login?user=patrick&password[%24gt]=
\end{lstlisting}

Pektov \cite{Petkov:2014a} demonstrated a vulnerable login implementation running on NodeJS's Express web server following the same approach. The application code given in listing \ref{lst:NodeQuerySelectorInjection} can also be attacked with the request presented in listing \ref{lst:QuerySelectorInjectionVector} . \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for query selector injection on MongoDB}, label={lst:NodeQuerySelectorInjection}]
db.collection('users').find({"user": req.query.user, "password": req.query.password});
\end{lstlisting}

So are there even any new findings for this class of attack? The previous publications presented the query selector injection as a distinct issue occurring only for PHP and Node applications, since its based a non-standardized application layer behavior. As explained in section \ref{sec:analysisOfQueryTechniques}, the query string parsing is a convenience functionality present across all investigated application platforms. The examples given in listing \ref{lst:RubyQuerySelectorInjection} for Ruby as well as listing \ref{lst:PythonQuerySelectorInjection} reveal, that query selector injection is an issue appearing across platforms. \\

\begin{lstlisting}[caption={Vulnerable Ruby example for query selector injection on MongoDB}, label={lst:RubyQuerySelectorInjection}]
db['users'].find({:user => req.params['user'], :password => req.params['password']})
\end{lstlisting}

\begin{lstlisting}[caption={Vulnerable Python example for query selector injection on MongoDB}, label={lst:PythonQuerySelectorInjection}]
db.users.find({"user": request.GET['user'], "password": request.GET['password']})
\end{lstlisting}

In all of the four cases, the default and by MongoDB recommended database driver was deployed. The attack vector from listing \ref{lst:QuerySelectorInjectionVector} leads in each of the presented login checks to the query criteria shown in listing \ref{lst:QuerySelectorCriteria}. \\

\begin{lstlisting}[caption={Resulting query of query selector injection}, label={lst:QuerySelectorCriteria}]
{'user': 'patrick', 'password': {'&gt':''}}
\end{lstlisting}

A login can therefore be bypassed in each investigated case, but this kind of attack is not restricted to login applications. Nearly all parameterized selection criteria can be influenced by the injection of query selectors. This includes all read, update and delete calls making use of the BSON selection format. Affected functions of the MongoDB API are listed in table \ref{tab:mongo_commands_affected}.\\


\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{lll}
  \textbf{Command} & \textbf{Arguments} \\ \hline
  db.collection.deleteOne         & \textbf{filter} options \\
  db.collection.deleteMany        & \textbf{filter} options \\
  db.collection.find              & \textbf{query} projection \\
  db.collection.findAndModify     & \textbf{query} options \\
  db.collection.findOne           & \textbf{query} projection \\
  db.collection.findOneAndDelete  & \textbf{filter} options \\
  db.collection.findOneAndReplace & \textbf{filter} replacement options \\
  db.collection.findOneAndUpdate  & \textbf{filter} update options \\
  db.collection.replaceOne        & \textbf{filter} replacement options \\
  db.collection.remove            & \textbf{query} option \\
  db.collection.update            & \textbf{query} update options \\
  db.collection.updateOne         & \textbf{filter} update options \\
  db.collection.updateMany        & \textbf{filter} update options \\
  \bottomrule 
 \end{tabular}
 \caption{MongoDB commands affected by query selector injection}
 \label{tab:mongo_commands_affected}
\end{table}

Considered are collection functions, that employ ether a \emph{filter} or \emph{query} parameter. Both facilitate the same JSON-like selection format. The affected functions encompass read, update and delete operations. Furthermore, the attacker surface analysis from section \ref{sec:analysisOfQueryTechniques} suggests, that the URL query string is by far not the only part of the attacker surface allowing this kind of attack. When the application processes other request parameters, the payload can also be placed in form data encoded as well as JSON request bodies. These circumstances exhibit a way more significant surface for query selector injection as previously indicated. \\

\subsection{Expanding Array Injection}
The expanding array injection is based on the common attacker model and exploits a special behavior of a query's selection criteria. When a requires a property to be equal to a value and the stored document contains an array in place of the property, all values of the array are used to find a match. This feature, as the attack name implies, is called automatic array expanding. An attacker can manipulate inserted documents in order to achieve matches subsequent selective criteria. The creation of an user as shown in listing \ref{lst:NodeJSCreateUser} represents an example for such an vulnerability. \\

\begin{lstlisting}[caption={Example for vulnerable MongoDB - NodeJS application}, label={lst:NodeJSCreateUser}]
if (req.query.user !== "admin") {
  db.collection('users').insert({"user": req.query.user, "password": req.query.password});
}
\end{lstlisting}

The given code allows the insertion of new users into the database, with the exception of \emph{admin} as a username. This security check can be bypassed, by injecting an array of usernames instead of a simple string. A suitable attack vector based on query string encoding is given with listing \ref{lst:ExpandingArrayInjection}.\\

\begin{lstlisting}[caption={MongoDB injection with NodeJS's query string module}, label={lst:ExpandingArrayInjection}]
https://example.org/register?user[]=patrick&user[]=admin&password=1234;
\end{lstlisting}

The given request creates an array-typed \emph{user} property that leads to the bypass of the if-clause. In the next step, the query is executed and the provided data results into the document presented in listing \ref{lst:ExpandingArrayInjectionDocument} stored within the user collection.\\

\begin{lstlisting}[caption={Injected query parameter for MongoDB - NodeJS injection}, label={lst:ExpandingArrayInjectionDocument}]
{'user': ['patrick', 'admin'], 'password': 1234}
\end{lstlisting}

At this point, the array expanding functionality becomes important. An attacker can now use the normal authentication with username and password as shown in listing \ref{lst:NodeJSArrayExpandingLogin} to login. This works for both of the users inserted with the initial request. \\

\begin{lstlisting}[caption={Example for vulnerable MongoDB - NodeJS application}, label={lst:NodeJSArrayExpandingLogin}]
db.collection('users').find({"user": req.query.user, "password": req.query.password});
\end{lstlisting}

The request for the login, does have to be manipulated. An attacker can now login as an amdin with a usual authentication request as shown in listing {lst:ArrayExpandingAdminLogin}.\\

\begin{lstlisting}[caption={MongoDB injection with NodeJS's query string module}, label={lst:ArrayExpandingAdminLogin}]
https://example.org/login?user=admin&password=1234;
\end{lstlisting}

MongoDb will search for a document with the user property set to \emph{admin} and the password property set to \emph{1234}. Through the expansion the the beforehand injected document or respectively the user property, a matching document is found and the admin login is successful.\\

The presented login application is of course not the only example, where the expanding array feature of MongoDB allow injection attacks. Every insert operation with data originating from the three parameters, that allow type manipulation represents a potential vulnerability. It enables an attacker to break the confidentiality of the underlying data, which leads to unintended matches for further requests. The attack was exemplified for the NodeJS, but is relevant for all of the investigated application layers. \\

\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{lllll}
  \textbf{Command} & \textbf{Arguments} \\ \hline
  db.collection.insert            & \multicolumn{3}{l}{\textcolor{dark-red}{\textbf{document}} | [ \textcolor{dark-red}{\textbf{document ... }} ] } \\
  db.collection.insertOne         & \textcolor{dark-red}{\textbf{document}} \\ 
  db.collection.update            & \textcolor{dark-blue}{\textbf{query}} \textcolor{dark-red}{\textbf{update}} options \\
  db.collection.updateOne         & \textcolor{dark-blue}{\textbf{filter}} \textcolor{dark-red}{\textbf{update}} options \\
  db.collection.updateMany        & \textcolor{dark-blue}{\textbf{filter}} \textcolor{dark-red}{\textbf{update}} options \\
  db.collection.replaceOne        & \textcolor{dark-blue}{\textbf{filter}} \textcolor{dark-red}{\textbf{replacement}} options \\\hline
  db.collection.deleteOne         & \textcolor{dark-blue}{\textbf{filter}} options \\
  db.collection.deleteMany        & \textcolor{dark-blue}{\textbf{filter}} options \\
  db.collection.find              & \textcolor{dark-blue}{\textbf{query}} projection \\
  db.collection.findAndModify     & \textcolor{dark-blue}{\textbf{query}} options \\
  db.collection.findOne           & \textcolor{dark-blue}{\textbf{query}} projection \\
  db.collection.findOneAndDelete  & \textcolor{dark-blue}{\textbf{filter}} options \\
  db.collection.findOneAndReplace & \textcolor{dark-blue}{\textbf{filter}} replacement options \\
  db.collection.findOneAndUpdate  & \textcolor{dark-blue}{\textbf{filter}} update options \\
  db.collection.remove            & \textcolor{dark-blue}{\textbf{query}}  option \\
  \bottomrule 
 \end{tabular}
 \caption{MongoDB commands affected by expanding array injection}
 \label{tab:mongo_commands_affected_expanding_array}
\end{table}

The presented login application is of course not the only example, where the expanding array feature of MongoDB allow injection attacks. Every insert operation with data originating from the three parameters, that allow type manipulation represents a potential vulnerability. It enables an attacker to break the confidentiality of the underlying data, which leads to unintended matches for further requests. The attack was exemplified for the NodeJS, but is relevant for all of the investigated application layers. \\

\section{Redis}
This section covers the injection attacks against the key-value store Redis, that were found in scope of this thesis.

\subsection{Parameter Overwrite Injection}
The parameter overwrite injection against Redis is based on the common attacker model. It requires NodeJS as an application platform in combination with the most used Redis driver. In order to understand this attack, it is essential to know how parameters can be accessed to the this particular database driver. The regular way allows to pass each parameter as distinct argument. An alternative way allows to pass all parameters within a single array as the first argument of the function call. With this knowledge and the control of the first argument, an attacker is able to overwrite the following arguments of an driver function call. An example application, where this becomes critical is shown in listing \ref{lst:parameterOverwriteApp}. \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for parameter overwrite injection on Redis}, label={lst:parameterOverwriteApp}]
RedisClient.expireat(req.query.key, new Date("November 8, 2026 11:13:00").getTime());
\end{lstlisting}

This code makes use of the \emph{expireat} functionality to set the data for the deletion of an entry. In this particular case, the expire date of the entry behind the passed key is set to a date far in the future. The user can therefore only extend the life of an entry behind an arbitrary key, but not really influence the stored data in a negative way. This situation changes, when the second parameter can be overwritten. A conceivable attack could set the expire data to a time in the past. An request, that triggers exactly this operation is shown in listing \ref{lst:parameterOverwriteAtt}. \\

\begin{lstlisting}[caption={Attack vector on Redis for query selector injection via HTTP GET}, label={lst:parameterOverwriteAtt}]
https://example.org/expire?key[]=foo&key[]=1117542887
\end{lstlisting}

Given the the query string parameters, the resulting array will be passed as the first argument to the database call. The following parameter, containing the future time will be overwritten. Instead the injected timestamp passed with with the array in the first argument will be used. Since this timestamp lays in the past, the stored data behind the provided key will be deleted. This enables an attacker to delete arbitrary entries of the database! Similar to the presented attack on \emph{expireat}, there exist multiple other affected database commands. An excerpt of commands, that are vulnerable for parameter overwrite injection are listed within table \ref{tab:redis_commands_affected}. \\

\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{lll}
  \textbf{Command} & \textbf{Arguments} & \textbf{Injection Description} \\ \hline
  Append  & key value       & Append a value to an arbitrary key\\
  DecrBy  & key decrement   & Decrement the integer value of a selected key \\
  Del     & key [key ...]   & Delete multiple selected keys at once \\
  Exists  & key [key ...]   & Check existence of multiple keys at once \\
  Expire  & key second      & Delete arbitrary key \\
  ExpireAt& key timestamp & Delete arbitrary key \\
  GetRange& key start end & Get entire content of key \\
  GetSet  & key value & Overwrite value of selected key \\
  IncrBy  & key increment & Increment the integer value of a selected key \\
  Move    & key db & Set destination database \\
  Rename  & key newkey & Set new key \\
  Set     & key value [expire] & Set arbitrary key-value data \\
  \bottomrule 
 \end{tabular}
 \caption{Redis commands affected by parameter overwrite injection}
 \label{tab:redis_commands_affected}
\end{table}

The investigation revealed, that many of the commands allow parameter overwrites and therefore corruption on of the underlying data. When the first key argument is controlled by an attacker, all following can be overwritten. These vulnerabilities enable an attacker to perform unintended insert, update or delete operations.

\section{CouchDB}
Within this section, the discovered injection attacks against the document store CouchDB are outlined.

\subsection{Find Selector Injection}
This attack is based on the common attacker model and directed against the find operation of CouchDB. The database facilitates two techniques to retrieve data. One is to reference the required document by its key. When selection criteria for other properties is needed, documents are queried with JSON-like selection criteria and the special \emph{\_find} document. This document is available for every database collection and resolves the passed selection criteria. The find selector injection focuses on manipulation of the provided selection criteria. Similar to MonogDB, complex criteria, like \emph{greater than} and \emph{not equals}, is encoded by query selector objects. These can be misused by object structure injection. The example given by listing \ref{lst:FindSelectorInjectionNodeJS} implements an credentials check and is vulnerable for find selector injection. \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for find selector injection on CouchDB}, label={lst:FindSelectorInjectionNodeJS}, language=JavaScript]
function checkCredentials(user, password, callback) {
  var options = {'selector': {'user': user, 'password': password}};
  couch.use('users').get('_find', options, (err, res) => {
    callback(res.docs.length === 1);
  });
}

checkCredentials(req.query.user, req.query.password, handleResult);
\end{lstlisting}

A function is implemented, that returns true or false depending on the success of the credentials check. The provided user and password value become part of the selector object, that is in turn contained within the options. Couch selects the user collection and performs a get operation with the help of the \emph{\_find} document and the composed options. Only when exactly one document is found that matches the selection criteria, the callback returns true. The described function is called with values provided by the request. Through object structure injection, the attack shown in listing \ref{lst:FindSelectorInjectionAttack} can be conducted. \\

\begin{lstlisting}[caption={Attack vector on CouchDB for speical key injection via HTTP GET}, label={lst:FindSelectorInjectionAttack}]
https://example.org/login?user=patrick&password[%24ne]=1
\end{lstlisting}

The payload contained within the query string of the URL leads to an object instead of a string typed password property. This object will replace the provided password value with a \emph{not equals} selector object within the query options. Therefore, the password check will reliably evaluate to true and the credentials check is bypassed. \\

\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{ll}
  \textbf{Operator} & \textbf{Description} \\ \hline
  \$lt      & less than argument\\
  \$lte     & less than or equal to argument \\
  \$eq      & equal to argument \\
  \$ne      & not equal to argument \\
  \$gte     & greater than or equal to the argument \\
  \$gt      & greater than argument \\
  \$exists  & field exists \\
  \$type    & type equals \\
  \$in      & contained in list \\
  \$nin     & not contained in list \\
  \$size    & length equal \\
  \$mod     & modulus equals remainder \\
  \$regex   & regular expression \\
  \$and     & all contained selectors match \\
  \$or      & any of the contained selectors matches \\
  \$not     & selector does not match \\
  \$nor     & no contained selector matches \\
  \$all     & contains all elements of argument list \\ 
  \$elemMatch & at least one of the contained selectors matches \\
  \bottomrule 
 \end{tabular}
 \caption{CouchDB's selector operations utilized for find selector injection}
 \label{tab:couchdb_affected_selectors}
\end{table}

\subsection{Special Key Injection}
The special key injection against CouchDB rests upon the common attacker model. In order to understand this attack, it is vital to be aware of CouchDB' storage concept. All data needed for its operation is treated as a document. This concerns application data as well as meta data of the existing collections. Security settings, operation history and data views are stored as documents within each collection. The only difference in comparison to normal documents is the prefixed underscore of the id. Meta data documents are accessible for every user with reading access on the collection. Special documents like those can be used to bypass application layer checks. Listing \ref{lst:SpecialKeyInjectionNodeJS} displays an authentication check vulnerable to special key injection. \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for special key injection on CouchDB}, label={lst:SpecialKeyInjectionNodeJS}, language=JavaScript]
function checkCredentials(user, password, callback) {
  couch.use('users').get(user, (err, res)=> {
    callback(res.password === password);
  });
}

checkCredentials(req.query.user, req.query.password, handleResult);
\end{lstlisting}

The snippet implements a \emph{checkUser} function, that receives a user and password argument. Since CouchDB's concept does not feature selection criteria, documents are retrieved by their id. Other properties of the stored documents, such as the password, cannot be filtered directly. In the presented case, the user property represents the document key and is used to query the stored record from the database. Password matching between the retrieved document and the passed argument is accomplished by the application layer. The result of the password matching is returned by the callback. \\

An attacker is able to pass this authentication check with the help of the stored meta data documents. The request presented in listing \ref{lst:SpecialKeyInjectionAttack} leads to a successful authentication.
 
\begin{lstlisting}[caption={Attack vector on CouchDB for speical key injection via HTTP GET}, label={lst:SpecialKeyInjectionAttack}]
https://example.org/login?user=_all_docs
\end{lstlisting}

With the provided user value, a special document is requested instead of of normal record. The database returns the \emph{\_all\_docs} document, that contains meta information about the collection. Important at that point is, that the special document does not contain a password property and is therefore undefined. Since the attack vector does not define a password value, the resulting argument is also undefined. Thus, two undefined values are compared for equality. JavaScript as well as Python, Ruby and PHP evaluate such a comparison to true and pass it to the callback. As a result, the credentials check is successfully bypassed.\\

CouchDB implements a group of these special documents for different purposes. Not all of these documents have the same access authorization level. Each of the special documents can be accessed by designated HTTP methods, as shown for a subset by table \ref{tab:couch_special_documents}. \\

\begin{table}[h]
 \sffamily
 \centering
 \begin{tabular}{llcccc}
  \textbf{Key} & \textbf{Description} & \textbf{GET} & \textbf{POST} & \textbf{PUT} & \textbf{DEL} \\ \hline
  \rowcolor{light-gray}\_all\_docs             & Return multiple documents of a database   & \cmark & \cmark & \xmark & \xmark \\
  \_bulk\_docs            & Create and update multiple documents      & \xmark & \cmark & \xmark & \xmark \\
  \rowcolor{light-gray}\_design                & Create or return views of database        & \cmark & \cmark & \xmark & \xmark \\
  \_find                  & Find documents with selection criteria    & \xmark & \cmark & \xmark & \xmark \\
  \rowcolor{light-gray}\_index                 & Get or create index                       & \cmark & \cmark & \xmark & \cmark \\
  \_explain               & Explain database structure                & \xmark & \cmark & \xmark & \xmark \\
  \rowcolor{light-gray}\_changes               & List of changes in the database           & \cmark & \cmark & \xmark & \xmark \\
  \_compact               & Run compression of database               & \xmark & \cmark & \xmark & \xmark \\
  \_ensure\_full\_commit  & Commits changes to disk                   & \xmark & \cmark & \xmark & \xmark \\
  \rowcolor{light-gray}\_security              & Return or set security object of database & \cmark & \xmark & \cmark & \xmark \\
  \_purge                 & Remove references to deleted documents    & \xmark & \cmark & \xmark & \xmark \\
  \_missing\_revs         & Return not stored revisions               & \xmark & \cmark & \xmark & \xmark \\
  \_revs\_diff            & Returns diff to stored revisions          & \xmark & \cmark & \xmark & \xmark \\
  \rowcolor{light-gray}\_revs\_limit           & Returns current revision limit            & \cmark & \xmark & \cmark & \xmark \\
  \bottomrule 
 \end{tabular}
 \caption{CouchDB special documents with description and applicable HTTP methods}
 \label{tab:couch_special_documents}
\end{table}

Depending on the operational purpose of the special document, designated HTTP methods are enabled. This has to be considered for attacks, since the injected special document needs to support the applied HTTP method of the exploited query. In case of the shown injection example, the HTTP GET method had to be supported. A major advantage of an attacker is, that even the lowest authorization level is allowed to GET special documents. Special key injection against queries using other HTTP methods require a higher authorization level of the underlying database user. A correctly configured application server and database should prevent higher authorization levels for normal database operations. \\

\subsection{Array Value Injection}
This attack is based on the common attacker model and directed against preliminary data validation. CouchDB implements protective measures for its special documents, but user defined documents have to be protected otherwise. Data checks within the application layer represent a solution for data protection. Inputs leading to illegitimate operations can be filtered beforehand in order to prevent query execution. At this point it is essential to filter all inputs giving a rise to the protected operation. Reliable filtering is hard to guarantee, when conditionals are handled differently on the application and database layer. Listing \ref{lst:couch_array_key_injection} gives an example for document protection, that can be bypassed by array value injection.\\

\begin{lstlisting}[caption={Vulnerable NodeJS example for array key injection on CouchDB}, label={lst:couch_array_key_injection}, language=JavaScript]
function getDocument(key, callback) {
  if (key === "secretDoc" || key[0] === "_") {
    callback("No access!");
  } else {
    couch.use('documents').get(key, callback);
  }
}

getDocument(req.query.key, handleResult);
\end{lstlisting}

The given code implements a function to retrieve documents by key. In order to protect the access on special documents and the \emph{secretDoc}, filters are applied. Special keys are filtered by the the first underscore char and the secret document is protected by direct key comparison. Every other key is passed to the query and the according document is returned. An attack has to search for a second query syntax, that allows access to the protected documents and all the same passes the preliminary checks. Listing \ref{lst:couch_array_key_injection_attack} presents two requests, that bypass the protective measures and retrieve the documents. \\

\begin{lstlisting}[caption={Attack vectors on CouchDB for array key injection via HTTP GET}, label={lst:couch_array_key_injection_attack}]
https://example.org?key[]=secretDoc
https://example.org?key[]=_all_docs
\end{lstlisting}

Basically, the attacks wrap an array around the passed key value. This achieves a different treatment of the parameter in the application and database layer. The filters use type safe condition evaluation. Therefore, the first attack vector injects an array which is not equal to the \emph{secretDoc} string. The second attack vector bypasses check, since the first element of the array does not equal the underscore char. Within the database layer, arrays containing just one element are resolved to the contained value. In both cases, the sensitive documents are returned. For this kind of vulnerability, similarities between string and array objects in the NodeJS, PHP, Ruby and Python environment become critical.   

\subsection{URL Traversal Injection}
The URL traversal injection against CouchDB rests upon the common attacker model. This attack relies on CouchDb's REST interface, that is used for any communication between application and database layer. REST uses URLs to identify the targeted documents. Some query parameters, such as the key, are used to build these URLs. Based on this, the key has influence on the structure of the URL. Applications as shown in listing \ref{lst:couchdb_url_traversal_injection_app} are vulnerable for URL traversal injection. \\

\begin{lstlisting}[caption={Vulnerable NodeJS example for URL traversal injection on CouchDB}, label={lst:couchdb_url_traversal_injection_app}, language=JavaScript]
function getDocument(key, callback) {
  couch.use('table').get(key, callback);
}

getDocument(req.query.key, handleResult);
\end{lstlisting}

\begin{lstlisting}[caption={Attack vectors on CouchDB for URL traversal injection via HTTP GET}, label={lst:PHPArrayInjection}]
https://example.org/get?key=_design/credentials/_view/user_password
\end{lstlisting}


\subsection{Data Import Injection}

\section{Memcached}
This section covers the injection attacks against the key-value cache Memcached, that were found in scope of this thesis.
\subsection{Array Key Injection}