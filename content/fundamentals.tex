 \chapter{Technical Background}
\label{cha:technicalBackground}
This chapter outlines the essential technologies and techniques in the context of NoSQL injection. Thereby, the relevant fundamentals in the scope of this thesis are covered.

\section{Underlying Technologies}
Within this section, the prevalent protocols and paradigms for data exchange between systems are explained.

\subsection{HTTP}
The Hypertext Transfer Protocol (HTTP) represents an application-layer protocol for the transfer of connected multimedia documents \cite{Berners-Lee1996}\cite{Fielding:1999}. Initially, HTTP was created regarding web-server to web-browser communication, but today the protocol is applied for various purposes. As a stateless protocol following a client-server model, HTTP itself does not retain any state between requests. While the protocol is often applied as a part of the TCP/IP stack, it is also applicable with other reliable and error-checked protocols on the transport layer. A required header block and an optional body block build the basic structure of each request and response. Depending on the intended kind of operation, different methods for requests exist. Table \ref{tab:http_methods} gives an overview of the available HTTP methods and their characteristics.\\

\begin{table}[h] 
 \centering
 \begin{tabular}{llccc}
  \textbf{\begin{tabular}{@{}c@{}}HTTP \\ method\end{tabular}} & \textbf{Description} & \textbf{\begin{tabular}{@{}c@{}}Request \\ body\end{tabular}} & \textbf{\begin{tabular}{@{}c@{}}Response \\ body\end{tabular}} & \textbf{Idempotent} \\ \hline
  GET     & Retrieve specified resource & \xmark & \cmark & \cmark \\
  HEAD    & Retrieve specified resource headers & \xmark & \xmark & \cmark \\
  POST    & Create specified resource & \cmark & \cmark & \xmark \\
  PATCH   & Partially updated specified resource & \cmark & \cmark & \xmark \\
  PUT     & Replace specified resource & \cmark & \cmark & \cmark \\
  DELETE  & Delete specified resource & \xmark & \cmark & \cmark \\ \midrule
  CONNECT & Convert connection to tunnel & \cmark & \cmark & \xmark \\
  OPTIONS & Return supported HTTP methods & \cmark & \cmark & \cmark \\
  TRACE   & Echo received request & \xmark & \cmark & \cmark \\
  \bottomrule
 \end{tabular}
 \caption{Overview of HTTP methods' characteristics}
 \label{tab:http_methods}
\end{table}

Basically, the first six methods implement create, read, update and delete operations for resources on the server. Thereby, a URI in the header specifies the resource, that the operation should be applied to. In case of create or update operations, the optional body block in the request contains the new resource data. Since no new data is needed for resource retrieving and deleting methods, they work solely with the request header block. All operations, apart form the HEAD request, deliver the result of the operation within the response's body block. Idempotents indicates, whether the behavior of a method stays the same for multiple consecutive requests. Especially update operations do not feature idempotent characteristics. The last three methods represent helper functions for connection inspection and TCP tunneling. An example for a request, that retrieves a specified resource form the server, is given in listing \ref{lst:http_request}.

\begin{lstlisting}[caption={HTTP GET request}, label={lst:http_request}]
GET /index.html HTTP/1.1
Host: example.org
Accept-Language: en
\end{lstlisting}

The first line of the request header is composed of the HTTP method, followed by resource identifier and completed with the version of the used protocol. In the given example a  GET request is used in order to retrieve the \textit{index.html} file. Afterwards, the host of the server is defined by the domain name. Accepted types of files, char-sets, encodings, languages and many more settings can be defined as additional headers. In case the requested resource exists and no error appears during request processing, the server sends a response as exemplified in listing \ref{lst:http_response}.

\begin{lstlisting}[caption={HTTP GET response}, label={lst:http_response}]
HTTP/1.1 200 OK
Date: Sat, 09 Sep 2016 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
\end{lstlisting}

In the first line of the response, the server version of the protocol as well as the status code and message are returned. Depending on the success of the request, the status code and message in the response change. Further headers contain meta information about the server, the requested resource and the body block. Separated by a blank line, the body block follows the header. In this example the body contains the requested HTML document. With the end of the response body, the HTTP request-response cycle is finished.

\subsection{REST}
Representational State Transfer (REST) describes a programming paradigm for distributed systems in a stateless client-server environment \cite{Fielding:2000}. It specifies an architectural style, that enforces a consistent system interface design. Therefore, REST represents an alternative to prior approaches, such as SOAP or WDSL. The paradigm separates resource location and the applied method. Functional instructions are therefore not allowed to be included within the URI. A special implementation or protocol is not defined by the paradigm, whereby REST is commonly used in combination with HTTP and HTTPS. In the course of this, the HTTP methods encode the functional instructions and resources has to be uniquely identified by the requested URI. Though, the usage of HTTP and HTTPS does not imply REST conformance. Methods are often misused for different functionalities and as a result REST conformance is not provided.

\section{NoSQL Databases}
This section gives an introduction to NoSQL databases and the idea behind this new class of data storage. NoSQL databases and their concepts, that are relevant in scope of this work, are outlined in detail.

\subsection{Overview}
In 1998 the word \textit{NoSQL} was first used by Carlo Strozzi in context of a relational, document-oriented database designed to be accessed without SQL. More than 10 years later in 2009, Johan Oskarsson reintroduced the term \textit{NoSQL} in oder to find a collective name for the increasing number of distributed, non-relational databases. From this time forward, the term was used with the meaning of \textit{not only SQL} or \textit{non relational} instead of \textit{no SQL}. Therefore, the term builds an umbrella term for databases without relational restrictions and often missing ACID support. The idea for such databases arose back in the 1960s, but the actual trend started with the challenges of big data. NoSQL databases addressed these challenges through their flexible data models, distributed storage, horizontal scaling abilities and independence from dedicated hardware. Currently around 225 databases are prevalent, that denote themselves as NoSQL storage. Despite the shared non-relational concept, NoSQL databases can be divided in different categories. Depending on the focused field of application, there exist four major groups:

\begin{description}
\item [Key-value Stores] These databases reference datasets with unique keys. Datasets are accessed with the key, that retrieves a pointer to the dataset from a hash table. Therefore data access over the key is very fast, but querying or updating single properties of a dataset is inefficient. Notable examples for key-value stores are Redis, Riak, Voledmort or Memcached.
\item [Document Stores] The main idea here is similar to key-value stores, but datasets also are composed of semistructured key-value pairs. These datasets are often called documents and are persisted in formats like JSON. This allows more efficient querying for single properties of a dataset. Notable examples for document stores are MongoDB, CouchDB or CouchBase.
\item [Graph databases] This group uses a flexible structure with nodes and edges to model graph structures. Depending on the implementation and the underlying data persistence, the data access differs. Some databases implement RESTful interfaces, others provide dedicated query APIs. Notable examples for graph databases are Neo4j, Titan or Graphite.
\item [Column Stores] Similar to relational databases, data is very structured, but the underlying persistence layer differs strongly. Data is arranged column after column instead of row after row. This column oriented storage allows the processing and especially analysis of large amounts of data over distributed systems. Notable examples for column stores are Apache Cassandra, HBase or SAP HANA.
\end{description}

Apart from the presented categories of NoSQL databases, there also exist hybrid models implementing features originating from multiple categories. An example is OrientDB, that combines a document store with graph database abilities. 

\subsection{MongoDB}
The non-relational, document-oriented database MongoDB was published as an open-source project in 2009. Deriving its name from the word humongous, it is designed to provide high performance, high availability as well as automatic horizontal scaling. The JSON style data model enables complex hierarchies for stored documents, but still allows efficient querying and indexing. Documents are stored in Binary JSON (BSON) format into collections, that in turn can be queried by JSON expressions. BSON extends JSON with additional data types, such as date, time stamps and regular expressions and is binary encoded. By default every MongoDB instance holds special system collections for indexes, namespaces, users and JavaScript code. MongoDB provides official drivers for various popular programming languages next to many unofficial community-supported drivers. 

\subsection{Redis}
Redis is an in-memory operating key-value store for strings, hashes, lists and sets. The 2009 released open-source database allows range queries and has built in Lua support for scripting. Due to its low data structure complexity, Redis provides large performance advantages in comparison to relational databases. Snapshotting or append only files allow on-disk persistence of the in-memory stored data. Later versions also allow distributed storage across clusters. Redis provides driver bindings for the most prevalent programming languages.

\subsection{Memcached}
The in 2003 released database Memcached is an in-memory key-value store for data caching. It allows to store and retrieve data from memory with hash tables distributed across multiple systems. Therefore, the result of requests to external sources can be cached and accessed much faster for subsequent access. Since the database is designed as a cache, data persistence on disc is not provided by default. Due to the resulting performance benefits of this approach, Memcached achieved wide prevalence and is deployed by companies like Facebook, YouTube, Twitter and Wikipedia. Drivers are provided for all major programming languages.


\subsection{CouchDB}
CouchDB is an document-oriented database written in Erlang. First published in 2005, the database is now maintained by the Apache Software Foundation and distributed under the Apache license. CouchDB is designed to combine the relaxed data model of document stores as well as the performance and scalability of relational databases. Therefore, the database offers horizontal scaling and implements the MapReduce framework for data processing. On Account of this, CouchDB includes Mozilla's JavaScript engine SpiderMonkey to facilitate scripting. Access for all major programming languages is provides with a RESTful HTTP interface. 

\section{Application Security}
In this section an introduction to the relevant security topics of this thesis is given. Therefore, the general state of NoSQl security is outlined and afterwards, the concept of injection attacks is described.
\subsection{NoSQL Security}
To give an overview of NoSQL security, multiple security aspects have to be considered. Data persisted to the disc has to be protected, but many NoSQL databases store data in rest unencrypted. That situation allows direct access, when the server is compromised. Authentication and authorization are also an important issue. By default, most NoSQL databases run without these mechanisms. This allows CSRF attacks or even direct, unauthenticated access, when the database ports are exposed to external systems. When it comes to inter-cluster and client communication, some databases are missing encryption. Last of all, also injection attacks represent an important security aspect of NoSQl databases. Despite other query languages than SQL are used, string concatenation of parameters still reveals attack surface.    

\subsection{Injection Attacks}
Injection vulnerabilities occur when data from untrusted sources is passed to an interpreter. According to the OWASP top ten project ranking web application security risks, injection attacks represent the most critical type overall. Everyone who is able to send untrusted data to the system could conduct an injection attack. Therefore, text-based payloads exploit the syntax of the interpreter in oder to achieve unintended behavior. As a result, code included in the payload is interpreted and executed. This may lead to data corruption, data loss, denial of access or even complete system takeover. SQL, LDAP, OS commands or XML are common formats, that are targeted by injection attacks. Best practice for injection prevention is the usage of parameterized APIs or alternatively stored procedures. The OWASP also recommends validation by white-listing input data.
