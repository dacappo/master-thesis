\chapter{Introduction to NoSQL Injection}
This section outlines the concept of NoSQL injection and how it derives from conventional SQL injection. A definition of NoSQL injection is given along with a detailed analysis of the corresponding attacker models.

\section{From SQL to NoSQL Injection}
\label{sec:fromSQLtoNoSQLinjection}
Injection attacks on relational databases represent the major web application vulnerability of the last decade. Thereby, the three tier architecture composed of client, server and database plays an important role. Since data obtained from the client can be arbitrary manipulated, input validation and sanitizing represent important principles for the the server-side. Otherwise, unvalidated input may find its way into sensitive operations, that cause injection vulnerabilities. In case unvalidated data is used to build database queries, an attacker is able to alter the SQL statement's structure. Suchlike vulnerabilities represent serious threats, especially due to the direct data access in combination with the Touring completeness of the injected SQL context.\\ 

This situation changed with the emerging generation of NoSQL databases. A variety of new query techniques was introduced next to SQL. For many databases, JSON-based or parameterized function calls replaced the conventional SQL approach. These simplified methods lead to a more straightforward database access and enabled unstructured data models. All the same, program logic moved from the database to the application layer due to functional limitations of the queries. Complex operations, such as data constraints or checks, that were previously executed directly on the database with SQL, have to be implemented within the application layer. Bypassing these logical constraints in order to achieve a certain database behavior constitutes an important aspect in the context of NoSQL injection. \\ 

Beside the query techniques, also the architecture of systems diversified with the emerged NoSQL databases. Relational databases are similar regarding their strengths and weaknesses, leading to a deployment in typical system structures, like the three tier model. In contrast to that, NoSQL databases discern in their focused area of application. Special requirements demand for tailored databases or even a combination of them. This leads to heterogeneous system landscapes deploying different databases and technology stacks for distinct purposes. Data exchange between multiple databases becomes an vital aspect that has to be managed. The resulting diversity of system designs as well as the data exchange between different data models has to be considered for the attack surface of NoSQL injection. All in all, NoSQL injection faces a much more diverse environment in contrast to conventional SQL injection.

\section{Definition of NoSQL Injection}

In order to give a definition for injection attacks against NoSQL databases, multiple aspects have to be taken into account. The objective of an attack has to be clarified as well as the mightiness of an attacker. In the course of this, the varying system structures has to be considered. Thus, attacker models for NoSQL injection expose themselves much more diverse in comparison to conventional SQL injection. In general, NoSQL injection can be defined the following way:\\

\begin{description}
\item [NoSQL Injection] represents a class of attacks against non-relational databases, that cause unintended behavior of a query through insertion of malicious data into the query context. These vulnerabilities originate from unvalidated user input used as or as a part of a database query. Depending on the attacked database, the injected input is crafted with the aim to trigger unintended operations of the database layer affecting confidentiality, integrity or availability of data.
\end{description}

Similar to other classes of attacks, NoSQL injection is directed against at least one of the three security goals - confidentiality, integrity and availability. This class of attack is focused on the database layer of an application or more precisely the therein stored data. The attacker goal of NoSQL injection is to compromise this data with regard to any of the mentioned security goals. Unauthorized modification or retrieval of data as well as restriction of data access for others, represent successful attacks. These results can be achieved by triggering malicious query behavior, especially with regard to typical create, read, update and delete operations. Malicious behavior can be accomplished through manipulation of existing queries as well as the invocation of unauthorized queries. Bypasses for preceding confidentiality and integrity checks allow such query manipulation and invocation and constitute an important aspect for this class of attacks. User provided input in turn enables users as well as attackers to influence database queries. When data received from user input is not properly sanitized for the query context, an attacker might be able to manipulate the semantics and structure of the database operation. Inputs provided by users derive from requests received from clients. Since their content can be manipulated, these requests represent the attacker surface for NoSQL injection. Arbitrary manipulation is only limited by the fixed protocol structure used for the request. Otherwise, further processing of the request on the recipient side may fail. For an attack, a request with adapted contents is built, that leads to a database query with malicious user input. The database interprets the triggered query in a way that breaks one of the security goals for the underlying data. These circumstances define a successful NoSQL injection attack.\\

The given definition of NoSQL injection is described in a relatively generic way. This goes in accordance with the in section \ref{sec:fromSQLtoNoSQLinjection} elucidated diverse system environments. On account of these circumstances, the way user input takes until it reaches the database query distinguishes depending on the system environment. Therefore, the phase between attacker initiated request and actual invocation of a database operation faces different scenarios. To address this in scope of the NoSQL injection definition, the following sections analyze the most significant system scenarios and outline the according attacker models.

\subsection{Common Attacker Model}
\label{sec:commonAttackerModel}

When analyzing the potential system structures of the NoSQL environment, the three tier model still plays a major role. The combination of client, application server and database layer represents a fundamental structure for web applications. This architectural style builds the basis for the long known class of SQL injection attacks. Non-relational databases are also often deployed in the same way. Therefore, the common attacker model from SQL injection applies in a similar way for NoSQL injection attacks. An overview of the according attacker model including the involved data flows is illustrated in figure \ref{fig:normalAttackerModel}.

\begin{figure}[h]
\centering
  \includegraphics[width=1\linewidth]{Images/attacker_model_normal}
  \caption{Common attacker model for NoSQL injection}
  \label{fig:normalAttackerModel}
\end{figure}

The common attacker model can be described with a request-response cycle between the tree tiers. Initial requests of these cycles are normally originating from a client-side application. Since these client-side applications are under the control of individual users, requests sent to the application layer can be arbitrary manipulated and represent untrusted data. An attacker takes advantage of this and undertakes the role of a user or respectively the client-side application. The communication between client and server therefore represents the attacker surface and determines the scope for content manipulation. In order to initiate an attack, a request with the designated payload is crafted and sent to the application server. There, the received request containing malicious data is processed and becomes part of a database query. On the database layer, the manipulated query is interpreted and the results of this operation are returned to the application-layer. The resulting data is indirectly influenced by the doctored query, is passed through the response processing and delivered to the attacker in order to finish the request-response cycle. All processing steps mentioned in this cycle make changes to the data. When implemented securely, untrusted data is sanitized in these processing steps and injection attacks are prevented. Incomplete or even missing input sanitizing for the query context lead to potential NoSQL injection vulnerabilities.\\

\begin{minipage}[t]{0.48\textwidth}
  \textbf{Attacker Mightiness} \\ 
  The attacker is aware of the deployed tree tier technology stack including the utilized communication protocols, application platform and database. He is able to send arbitrary manipulated requests to the application server. Direct access to the NoSQL database layer for the attacker is not given.
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
  \textbf{Attacker Goal} \\ 
  The attacker aims to achieve unintended behavior of at least one database query by altering its parameters. A successful attack compromises confidentiality, integrity or availability of the underlying data through the query processing step or the data received with the resulting response.
\end{minipage}

\subsection{Extended Attacker Model}

The emergence of NoSQL databases entailed diverse system structures and high data exchange between components as explained in section \ref{sec:fromSQLtoNoSQLinjection}. Multiple systems are deployed for different purposes and therefore exchange their data. As a consequence, data is transformed between different data models. A benign entry in one system may be critical in another one. An entry valid in one context, may result in a vulnerability when imported to another context. Therefore, data exchange becomes a critical aspect for interconnected systems. This situation has to be considered for determination of feasible attacker models. Figure \ref{fig:extendedAttackerModel} addresses suchlike environments and presents an extended attacker model. \\

\begin{figure}[h]
\centering
  \includegraphics[width=1\linewidth]{Images/attacker_model_extended}
  \caption{Extended attacker model for NoSQL injection}
  \label{fig:extendedAttackerModel}
\end{figure}

This model extends the common attacker model described in section \ref{sec:commonAttackerModel} by a preceding step. NoSQL system circumstances do not necessarily allow the assumption, that the underlying data is completely tamper-proof. In this model, the database layer imports data from at least one external source. This source can be a file, another database or even an complete external system. The procedure of an attack begins with manipulated data added to this external source. It has to be clarified, that the added data can be totally eligible in this context. Any import of this data, into another system leads to a tampered data stock. The degree of attacker influence depends on the import processing, but in the worst case, the data is transfered one-to-one. This means, that such a preliminary step allows an attacker to add arbitrary manipulated records to the attacked database. In a second step the procedure of the common attacker model is executed. The question is, whether this extended model allows new kind of injection attacks not applicable for the common model. Certainly, the definition of attack mightiness and goal have to be adapted for the extended model as follows. \\

% 2-step approach
% assumption to be able to insert arbitrary data into a external system or further 
% attacker is able to insert arbitrary entry in database
% ATTACKER Mightiness + GOAL (- insert)

% Objective
\begin{minipage}[t]{0.48\textwidth}
  \textbf{Attacker Mightiness} \\ 
  The attacker is aware of the entire deployed technology stack including the utilized communication protocols, application platform, database and external data source. He is able to insert arbitrary manipulated data to the external source and send arbitrary manipulated requests to the application server. Direct access to the NoSQL database layer for the attacker is not given.
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
  \textbf{Attacker Goal} \\ 
  The attacker aims to achieve unintended behavior of at least one database query by altering its parameters. A successful attack compromises confidentiality, integrity or availability of the underlying data, that not derived from the attacker. This can be achieve as a result of the import process, query processing step or the data received with the resulting response.
\end{minipage}


\subsection{Direct Attacker Model}
Another scenario that become important with NoSQL databases is direct communication between client and database layer. This is represented by a reduced three teer architecture, that does not deploy any application layer. The idea seems inconvenient, but is actually induced by multiple NoSQL databases. In contrast to the extended attacker model, also a simplified model is needed to address these kind of system structure. The two tier architecture and the corresponding attacker model are visualized within figure \ref{fig:directAttackerModel}.

\begin{figure}[h]
\centering
  \includegraphics[width=1\linewidth]{Images/attacker_model_direct}
  \caption{Direct attacker model for NoSQL injection}
  \label{fig:directAttackerModel}
\end{figure}

The direct attacker model is based on a request-response cycle between client and database layer. Similar to the other models, the attacker overtakes the role of the client-side application and crafts a request containing the payload. This request is sent directly to the database layer. An important aspect of the entire attacker model is the authentication and authorization mechanism of the database. Otherwise, an attacker would be able to invoke arbitrary queries. In the scope of this model, the attacker is restricted by the authorization of an typical application user. At this point the granularity of the applied checks plays an important role. An successful attacker may craft a request, that passes the authorization checks and still triggers a potentially malicious behavior of the processed query. The major advantage for an attacker is that the manipulated request and resulting response are not processed, filtered or protected by any application layer. \\

\begin{minipage}[t]{0.48\textwidth}
  \textbf{Attacker Mightiness} \\ 
  The attacker is aware of the entire deployed technology stack including database layer, authorization checks and utilized communication protocol. He is able to send arbitrary manipulated requests directly to the database layer. This scenario implies direct access for the attacker to the attacked database with user-level authorization.
\end{minipage}
\hfill
\begin{minipage}[t]{0.48\textwidth}
  \textbf{Attacker Goal} \\ 
  The attacker aims to achieve unintended behavior the attacked database. A successful attack compromises confidentiality, integrity or availability of the underlying data through the query processing step or the data received with the resulting response.
\end{minipage}

\subsection{Combined Attacker Models}
With the previously outlined attacker models, the diverse scenarios for NoSQL-based systems are covered. The extended attacker model addresses the aspects of complex and unstructured data exchange between system components. With the direct attacker model the simplified two-tier architectures are taken into account. Due to the diverse system structures entailed by NoSQL databases, also combinations of these models become relevant in special cases. In comparison to the pretty uniform relational database environment, the definition of a holistic attacker model for the heterogeneous NoSQL environment is hard to ensure. Nevertheless, with the three presented attacker models, the most prevalent application structures of NoSQL databases are covered for the scope of this thesis. \\

By the detailed definition of NoSQL injection and the introduction of corresponding known as well as new attacker models, the in section \ref{sec:objective} set \textbf{Objective 1} is covered and the basis for the following elaboration is given.


\section{Considered Technology Stack}

The previously defined attacker models are held generic by not involving involve concrete databases, protocols or application servers. In this way, a holistic definition for NoSQL injection could be given. However, actual vulnerabilities and according attack vectors depend on designated technology configurations. With regard to the objective of NoSQL injection investigation, a scope for the considered technologies has to be set. An examination of all feasible technology combinations is not viable. This section selects the most prevalent technologies of each layer for the further investigation in scope of this thesis.

\subsection{Selected Databases}

The database layer constitutes a key aspect for the investigation of NoSQL injection. In order to provide a comprehensive exploration of the topic, the prevalence of the databases represents an important factor. The underlying data structures as well as query techniques have to be considered for a diverse selection, too. Especially databases, that implement concepts differing strongly form the well explored relational approach represent suitable candidates. As a basis for the selection, a ranking rating the popularity of databases was used. An extract of the top ranking non-relational databases is shown in table \ref{tab:db_ranking}.

% focused on non-relational databaes, therefore most widespread NoSQl databases selected
% DB-rankings show importances of databases
% select concepts, that differ strongly from relational databses - skip equal approaches based on SQL-like query languages
% differn types in scope of this work
\definecolor{light-gray}{rgb}{0.92,0.92,0.92}
\begin{table}[h] 
 \centering
 \begin{tabular}{cllcc}
  \textbf{NoSQL Rank} & \textbf{Database} & \textbf{Type} & \textbf{Overall Rank} & \textbf{Trend} \\ \hline
  \rowcolor{light-gray} 1. &  MongoDB     & Document store & 4. & $\scriptstyle\nearrow$ \\
  2. &  Cassandra   & Column store & 7. & $\rightarrow$ \\
  \rowcolor{light-gray} 3. &  Redis       & Key-value store & 9. & $\scriptstyle\nearrow$ \\
  4. &  HBase       & Column store & 15. & $\rightarrow$ \\
  5. &  Neo4j       & Graph store & 21. & $\rightarrow$ \\
  6. &  Couchbase  & Document store & 22. & $\rightarrow$ \\
  \rowcolor{light-gray} 7. &  Memcached & Key-value store & 23. & $\rightarrow$ \\
  8. &  DynamoDB & Document store & 24. & $\scriptstyle\nearrow$ \\
  \rowcolor{light-gray} 9. &  CouchDB   & Document store & 27. & $\scriptstyle\searrow$ \\
  10. &  Riak KV & Key-value store & 32. & $\scriptstyle\searrow$ \\
  \bottomrule
 \end{tabular}
 \caption{Ranking of databases according to their popularity}
 \label{tab:db_ranking}
\end{table}

Listed are the ten most popular non-relational databases measured by a combination of search trends, social network and developer discussions as well as job offerings. Every entry contains the name of the database or more precisely the database management system, the type of the underlying data model, its overall rank considering relational databases and search engines and the popularity trend of the last month. 



% Why the others are slected for investigation, is outlined in the listing below

\begin{description}
\item [MongoDB] represents the prime non-relational database of the ranking and the trend indicates further growth. This document store challenges the leading relational databases and is therefore a suitable candidate for further investigation. 
\item [Redis] is the highest ranking key-value store and exhibits the uppermost growth rate of all listed NoSQL databases. Its growth is also reflected by the shown trend scores. With the in-memory stored key-value pairs, a new concept arrived in leading databases. These circumstances make Redis the second databases, considered for the scope of this work.
\item [Memcached] is another key-value store, but differs strongly from others like Redis. This database is optimized for any kind of caching on distributed systems. Data is only store temporarily and never persisted to disc. Due to the discrete approach of this database, is represents the third candidate for NoSQL injection examination.
\item [CouchDB] implements another document-store with an declining popularity trend. Since its concepts differs strongly from other document stores and builds the basis for multiple other non-relational databases, it still embodies an interesting database for the investigation of injection attacks.
\end{description}

The second ranking non-relational database Apache Cassandra and the fourth ranking HBase are not considered, since their querying techniques are based on SQL-like languages and prepared statements are offered as a secure injection mitigation technique. In case of the graph structured Neo4j data store, the same reasons apply. Concepts relatively close to the relational approach can probably secured with known techniques and are hence not addressed by this thesis. Couchbase is in large parts a fork of the selected CouchDB, implements an similar approach and therefore not taken into account. The main reason for the disregarding of DynamoDB is its proprietary nature as a part of Amazon web service products. Last of all, the Riak key-value store is not considered, because of its similar approach with Redis and declining popularity. With the selected four candidates for NoSQl injection investigation, a broad range of non-relational concepts is covered.


\subsection{Selected Application Platforms}
Next to the underlying database, a series of application platforms have to be selected regarding the common and the extended attacker model. An optimal choice would be application layers that are most frequently deploy in combination with the selected NoSQL databases. Unfortunately, representative statistics for suchlike cases are not available. Another option is the analysis of open-source applications with regard to the used programming language. GitHub's open repositories provide a broad range of projects, that allow an evaluation of a programming languages' popularity. Exactly this information was gathered and published by a GitHub engineer and builds the basis for the application layer selection for this thesis. The top ranking programming languages of more than a million analyzed public repositories are summarized in table \ref{tab:language_ranking}.

\begin{table}[h] 
 \centering
 \begin{tabular}{clrr}
  \textbf{Rank} & \textbf{Repository Language} & \textbf{Active Repositories} & \textbf{Total Commits} \\ \hline
  \rowcolor{light-gray} 1. &  JavaScript     & 323,938 & 3,461,415 \\
  2. &  Java   & 222,852 & 2,323,315 \\
  \rowcolor{light-gray} 3. &  Python  & 164,852 & 1,654,226 \\
  4. &  CSS       & 164,585 & 1,810,013 \\
  \rowcolor{light-gray}5. &  PHP      & 138,771 & 1,391,467 \\
  \rowcolor{light-gray}6. &  Ruby  & 132,848 & 1,106,259 \\
   7. &  C\scriptsize\raisebox{.5ex}{++} & 86,505 & 1,013,761 \\
  8. &  C & 73,075 & 804,339 \\
  9. &  Shell   & 65,670 & 592,046 \\
  10. &  C\scriptsize\raisebox{.5ex}{\#} & 56,062 & 558,332 \\
  \bottomrule
 \end{tabular}
 \caption{Ranking of programming languages according to the number of public repositories on GitHub in 2014}
 \label{tab:language_ranking}
\end{table}
Listed are the ten most used repository languages of public projects along with the number of active repositories and the total of push commits. The reasons for the selection of the highlighted programming languages and the corresponding application layers are listed below.

\begin{description}
\item [NodeJS] represents the server-side execution environment of JavaScript. As shown in the ranking, JavaScript is by far the most used language in the analyzed open-source projects. The language is used within browsers on the client-side as well as for server-side applications. Many non-relational databases even allow direct scripting with this language. Therefore, JavaScript or respectively the server-side NodeJS is selected for further investigation.
\item [Python] is the third highest ranking programming language and known for its fast and easy prototyping abilities. Common use-cases represent server-side scripting and web development. Its characteristics make Python an essential application layer for the scope of this work.
\item [PHP] is the most widespread server-side application layer of web applications. That is reflected with the fifth place in the popularity ranking of programming languages. Since the typical deployment of PHP resembles the presented attacker models, the language is taken into account for the scope of this work.
\item [Ruby] is nearly as popular as PHP regarding the number of active repositories. In combination with the Rails framework, Ruby represents an established application layer for web applications. On this account Ruby is selected as the fourth application layer language for NoSQL injection investigation.
\end{description}

With the selected four application layers a broad realm for our attacker models is covered. The languages are part of many examples used for the introduction NoSQL databases. Despite its high ranking, Java is not considered for further investigation. This decision is based on the high number of Android repositories, that are not suitable for the presented attacker models. CSS was omitted, since it is no typical application language and only offers styling capabilities for websites.

% focus on typical web stack application layers
% mostly dynamically typed
% therefore Node.js, PHP, Ruby and Python selected for scope of this thesis


\subsection{Selected Application Layer Protocols}

Through the selection of databases and application platforms, the applicable communications protocols are already entailed. The attacker models enable an attacker to send arbitrary manipulated requests. An important restriction at this point is, that the request has to be interpreted and the contained payload processed by the application or database layer. Therefore, protocol-breaking request are mostly discarded. Manipulation of requests is for this reason restricted to designated parts in practice. Theoretically any application layer protocol or even lower-level ones can be used for cross-layer communication. For the selected technology stacks, HTTP and HTTPS represents the relevant protocols regarding the attacker surface. The following list explains the components, that are predestinated for attacker manipulation.

\textbf{HTTP}
\textbf{HTTPS}

\textbf{JSON}
\textbf{URL Encoded}
\textbf{XML}

% implied by selected aplplication plfatforms, but theoretically any appplication layer protocl or even lower-level protocols prossible
% focused on HTTP/HTTPS as attacker surface, but other protocols possible
% control over entire request, in case of HTTP HEADER + BODY and the HTTP-Method
% Which HTTP methods are relevant (CRUD)
% parameters for application server interesting, these usually are used for server-side processing
% Body (JSON, XML, x-www-form-urlencoded), Header (Cookies), URL (Querystring, Path)
% type of system architecture to attack
% ACTUAL definition of Attacker surface